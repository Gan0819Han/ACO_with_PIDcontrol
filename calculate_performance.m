function J = calculate_performance(Kp, Ki, Kd, plant, rho)
% =========================================================================
%                         计算PID性能指标J (已修正)
% =========================================================================
%
% 功能:
% 对于给定的一组Kp, Ki, Kd参数，此函数通过仿真计算系统的性能指标J。
%
% 修正说明 (2025-06-10):
% 修正了原先会导致“非因果模型”仿真错误的bug。
% 通过在创建pid对象时加入一个小的滤波器时间常数Tf，确保了微分项
% 的物理可实现性，从而使整个系统可以被正确仿真。
%
% =========================================================================

    % --- 创建PID控制器 (加入D项滤波器使其物理可实现) ---
    % 理想的D项 (Kd*s) 会导致非因果系统，无法仿真。
    % 实际的PID控制器总会包含一个滤波器。我们在这里加入一个小的
    % 滤波器时间常数 Tf，使得控制器传递函数是正常的 (proper)。
    Tf = 0.01; % 滤波器时间常数，一个典型的小值
    C = pid(Kp, Ki, Kd, Tf);

    % 构建闭环反馈系统
    sys_closed = feedback(C * plant, 1);

    % 检查系统稳定性。若不稳定，则返回一个巨大的J值作为惩罚。
    if ~isstable(sys_closed)
        J = 1e10; % 稳定性惩罚
        return;
    end

    % --- 仿真系统阶跃响应 ---
    t_final = 2.0; % 仿真时长
    dt = 0.01;     % 时间步长
    t = 0:dt:t_final;
    
    % 计算系统输出 y(t)
    [y, ~] = step(sys_closed, t);

    % 计算误差 e(t) = r(t) - y(t)，其中 r(t) 为单位阶跃输入，恒为1
    e = 1.0 - y;

    % --- 计算控制量 u(t) ---
    % U(s)/R(s) = C / (1 + C*G)
    % 这里的控制器 C 已经包含了滤波器，因此 sys_u 是正常的。
    sys_u = feedback(C, plant);
    u = step(sys_u, t);
    
    % --- 计算性能指标 J ---
    % J = ∫(e(t)² + ρ * u(t)²)dt
    % 这个指标旨在最小化误差，同时限制控制能量的过度使用。
    J = sum(e.^2 + rho * u.^2) * dt;

    % 可以加入对超调量的惩罚
    overshoot = max(y) - 1;
    if overshoot > 0
        J = J * (1 + 10 * overshoot); % 施加超调惩罚
    end

    % 最终检查J值是否有效，防止NaN或Inf污染优化过程
    if isnan(J) || isinf(J)
        J = 1e10; % 如果计算出错，同样返回一个巨大的惩罚值
    end
end
